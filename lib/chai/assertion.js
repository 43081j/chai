/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
import { config } from './config.js';
import { AssertionError } from 'assertion-error';
import * as util from './utils/index.js';
const getDefaultValue = (assertion) => {
    var newAssertion = Assertion.create();
    util.transferFlags(assertion, newAssertion);
    return newAssertion;
};
/*!
 * Assertion Constructor
 *
 * Creates object for chaining.
 *
 * `Assertion` objects contain metadata in the form of flags. Three flags can
 * be assigned during instantiation by passing arguments to this constructor:
 *
 * - `object`: This flag contains the target of the assertion. For example, in
 *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
 *   contain `numKittens` so that the `equal` assertion can reference it when
 *   needed.
 *
 * - `message`: This flag contains an optional custom error message to be
 *   prepended to the error message that's generated by the assertion when it
 *   fails.
 *
 * - `ssfi`: This flag stands for "start stack function indicator". It
 *   contains a function reference that serves as the starting point for
 *   removing frames from the stack trace of the error that's created by the
 *   assertion when it fails. The goal is to provide a cleaner stack trace to
 *   end users by removing Chai's internal functions. Note that it only works
 *   in environments that support `Error.captureStackTrace`, and only when
 *   `Chai.config.includeStack` hasn't been set to `false`.
 *
 * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
 *   should retain its current value, even as assertions are chained off of
 *   this object. This is usually set to `true` when creating a new assertion
 *   from within another assertion. It's also temporarily set to `true` before
 *   an overwritten assertion gets called by the overwriting assertion.
 *
 * - `eql`: This flag contains the deepEqual function to be used by the assertion.
 *
 * @param {Mixed} obj target of the assertion
 * @param {String} msg (optional) custom error message
 * @param {Function} ssfi (optional) starting point for removing stack frames
 * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
 * @api private
 */
export class Assertion {
    constructor(obj, msg, ssfi, lockSsfi) {
        this.__methods = {};
        util.flag(this, 'ssfi', ssfi || Assertion);
        util.flag(this, 'lockSsfi', lockSsfi);
        util.flag(this, 'object', obj);
        util.flag(this, 'message', msg);
        util.flag(this, 'eql', config.deepEqual ?? util.eql);
    }
    static create(obj, msg, ssfi, lockSsfi) {
        return util.proxify(new Assertion(obj, msg, ssfi, lockSsfi));
    }
    static get includeStack() {
        console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
        return config.includeStack;
    }
    static set includeStack(value) {
        console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
        config.includeStack = value;
    }
    static get showDiff() {
        console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
        return config.showDiff;
    }
    static set showDiff(value) {
        console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
        config.showDiff = value;
    }
    static addProperty(name, fn) {
        util.addProperty(this.prototype, name, fn, getDefaultValue);
    }
    static addMethod(name, fn) {
        util.addMethod(this.prototype, name, fn, getDefaultValue);
    }
    static addChainableMethod(name, fn, chainingBehavior) {
        util.addChainableMethod(this.prototype, name, fn, chainingBehavior, getDefaultValue);
    }
    static overwriteProperty(name, fn) {
        util.overwriteProperty(this.prototype, name, fn, getDefaultValue);
    }
    static overwriteMethod(name, fn) {
        util.overwriteMethod(this.prototype, name, fn, getDefaultValue);
    }
    static overwriteChainableMethod(name, fn, chainingBehavior) {
        util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior, getDefaultValue);
    }
    /**
     * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
     *
     * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
     *
     * @name assert
     * @param {Philosophical} expression to be tested
     * @param {String|Function} message or function that returns message to display if expression fails
     * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
     * @param {Mixed} expected value (remember to check for negation)
     * @param {Mixed} actual (optional) will default to `this.obj`
     * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
     * @api private
     */
    assert(_expr, msg, _negateMsg, expected, _actual, showDiff) {
        var ok = util.test(this, arguments);
        if (false !== showDiff)
            showDiff = true;
        if (undefined === expected && undefined === _actual)
            showDiff = false;
        if (true !== config.showDiff)
            showDiff = false;
        if (!ok) {
            msg = util.getMessage(this, arguments);
            var actual = util.getActual(this, arguments);
            var assertionErrorObjectProperties = {
                actual: actual,
                expected: expected,
                showDiff: showDiff,
                operator: undefined
            };
            var operator = util.getOperator(this, arguments);
            if (operator) {
                assertionErrorObjectProperties.operator = operator;
            }
            throw new AssertionError(msg, assertionErrorObjectProperties, (config.includeStack) ? this.assert : util.flag(this, 'ssfi'));
        }
    }
    /*!
     * ### ._obj
     *
     * Quick reference to stored `actual` value for plugin developers.
     *
     * @api private
     */
    get _obj() {
        return util.flag(this, 'object');
    }
    set _obj(val) {
        util.flag(this, 'object', val);
    }
}
//# sourceMappingURL=assertion.js.map